{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"\u4e3b\u9801"},{"location":"intro/","text":"\u95dc\u65bc\u672c\u7ad9 \u00b6 \ud83d\uddd3\ufe0f Solutions to the problems from Daily Coding Problem . You can subscribe to that service and then it will send a coding task to you every day for practicing and enhancing your problem-solving ability. \u5efa\u7f6e\u65b9\u6cd5 \u00b6 \u672c\u7ad9\u4f7f\u7528\u975c\u614b\u7db2\u9801\u751f\u6210\u5668 MkDocs \u69cb\u5efa\uff0c\u63a1\u7528 Material for MkDocs \u4e3b\u984c\uff0c\u9801\u9762\u90e8\u5206\u7a0b\u5f0f\u78bc\u8a17\u7ba1\u65bc GitHub \u5009\u5eab\u7684 docs \u5206\u652f\uff0c\u900f\u904e GitHub Actions \u670d\u52d9\u81ea\u52d5\u90e8\u7f72\u65bc https://dcp.hsins.me/ \u3002 \u6388\u6b0a\u8a31\u53ef \u00b6 Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"\u95dc\u65bc\u672c\u7ad9"},{"location":"intro/#_1","text":"\ud83d\uddd3\ufe0f Solutions to the problems from Daily Coding Problem . You can subscribe to that service and then it will send a coding task to you every day for practicing and enhancing your problem-solving ability.","title":"\u95dc\u65bc\u672c\u7ad9"},{"location":"intro/#_2","text":"\u672c\u7ad9\u4f7f\u7528\u975c\u614b\u7db2\u9801\u751f\u6210\u5668 MkDocs \u69cb\u5efa\uff0c\u63a1\u7528 Material for MkDocs \u4e3b\u984c\uff0c\u9801\u9762\u90e8\u5206\u7a0b\u5f0f\u78bc\u8a17\u7ba1\u65bc GitHub \u5009\u5eab\u7684 docs \u5206\u652f\uff0c\u900f\u904e GitHub Actions \u670d\u52d9\u81ea\u52d5\u90e8\u7f72\u65bc https://dcp.hsins.me/ \u3002","title":"\u5efa\u7f6e\u65b9\u6cd5"},{"location":"intro/#_3","text":"Licensed under the MIT License, Copyright \u00a9 2020-present Hsins.","title":"\u6388\u6b0a\u8a31\u53ef"},{"location":"intro/faq/","text":"\u5e38\u898b\u554f\u984c \u00b6","title":"\u5e38\u898b\u554f\u984c"},{"location":"intro/faq/#_1","text":"","title":"\u5e38\u898b\u554f\u984c"},{"location":"intro/problems/","text":"\u984c\u76ee\u5217\u8868 \u00b6 No. \u540d\u7a31 \u96e3\u5ea6 \u53c3\u8003\u89e3\u7b54 1. Two Sum Easy \u89e3\u7b54 2. Product of Array Except Self Hard \u89e3\u7b54 3. Serialize and Deserialize Binary Tree Hard \u89e3\u7b54 4. First Missing Positive Hard \u89e3\u7b54 5. Function car, cdr and cons Medium \u89e3\u7b54 6. XOR Linked List Hard \u89e3\u7b54 7. Decode Ways Medium \u89e3\u7b54 8. Count Univalue Subtrees Easy \u89e3\u7b54 9. Maximum Sum of Non-Adjacent Elements Hard \u89e3\u7b54 10. Job Scheduler Medium \u89e3\u7b54","title":"\u984c\u76ee\u5217\u8868"},{"location":"intro/problems/#_1","text":"No. \u540d\u7a31 \u96e3\u5ea6 \u53c3\u8003\u89e3\u7b54 1. Two Sum Easy \u89e3\u7b54 2. Product of Array Except Self Hard \u89e3\u7b54 3. Serialize and Deserialize Binary Tree Hard \u89e3\u7b54 4. First Missing Positive Hard \u89e3\u7b54 5. Function car, cdr and cons Medium \u89e3\u7b54 6. XOR Linked List Hard \u89e3\u7b54 7. Decode Ways Medium \u89e3\u7b54 8. Count Univalue Subtrees Easy \u89e3\u7b54 9. Maximum Sum of Non-Adjacent Elements Hard \u89e3\u7b54 10. Job Scheduler Medium \u89e3\u7b54","title":"\u984c\u76ee\u5217\u8868"},{"location":"intro/styleguide/","text":"\u683c\u5f0f\u6307\u5357 \u00b6","title":"\u683c\u5f0f\u6307\u5357"},{"location":"intro/styleguide/#_1","text":"","title":"\u683c\u5f0f\u6307\u5357"},{"location":"intro/test/","text":"\u6e2c\u8a66\u6587\u4ef6 \u00b6 Abbreviations \u00b6 The HTML specification is maintained by the W3C . Admonitions \u00b6 Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Content Tabs \u00b6 C #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } C++ #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } Tables \u00b6 Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource Math Equations \u00b6 Using block syntax \u00b6 \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"\u6e2c\u8a66\u6587\u4ef6"},{"location":"intro/test/#_1","text":"","title":"\u6e2c\u8a66\u6587\u4ef6"},{"location":"intro/test/#abbreviations","text":"The HTML specification is maintained by the W3C .","title":"Abbreviations"},{"location":"intro/test/#admonitions","text":"Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim.","title":"Admonitions"},{"location":"intro/test/#content-tabs","text":"C #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } C++ #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; }","title":"Content Tabs"},{"location":"intro/test/#tables","text":"Method Description GET :material-check: Fetch resource PUT :material-check-all: Update resource DELETE :material-close: Delete resource","title":"Tables"},{"location":"intro/test/#math-equations","text":"","title":"Math Equations"},{"location":"intro/test/#using-block-syntax","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"Using block syntax"},{"location":"note/","text":"\u9032\u5236\u8f49\u63db","title":"\u7b46\u8a18"},{"location":"note/number-system-conversion/","text":"\u9032\u5236\u8f49\u63db \u00b6 \u5341\u9032\u5236\u8f49\u4e8c\u9032\u5236 \u00b6 \" {0:b} \" . format ( 10 ) = 1010 bin ( 6 )[ 2 :] = 110 bin ( 10 )[ 2 :] . zfill ( 4 ) = 1010 \u53c3\u8003\u8cc7\u6599 \u00b6 DataCamp | Python Data Type Conversion Tutorial Stackoverflow | Remove The 0b in Binary","title":"\u9032\u5236\u8f49\u63db"},{"location":"note/number-system-conversion/#_1","text":"","title":"\u9032\u5236\u8f49\u63db"},{"location":"note/number-system-conversion/#_2","text":"\" {0:b} \" . format ( 10 ) = 1010 bin ( 6 )[ 2 :] = 110 bin ( 10 )[ 2 :] . zfill ( 4 ) = 1010","title":"\u5341\u9032\u5236\u8f49\u4e8c\u9032\u5236"},{"location":"note/number-system-conversion/#_3","text":"DataCamp | Python Data Type Conversion Tutorial Stackoverflow | Remove The 0b in Binary","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/","text":"","title":"365. WORK IN PROGRESS"},{"location":"problem/climbing-stairs/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 There exists a staircase with N steps, and you can climb up either 1 or 2 steps at a time. Given N , write a function that returns the number of unique ways you can climb the staircase. The order of the steps matters. For example, if N is 4 , then there are 5 unique ways: 1, 1, 1, 1 2, 1, 1 1, 2, 1 1, 1, 2 2, 2 What if, instead of being able to climb 1 or 2 steps at a time, you could climb any number from a set of positive integers X ? For example, if X = {1, 3, 5} , you could climb 1 , 3 , or 5 steps at a time. \u53c3\u8003\u8cc7\u6599 \u00b6","title":"012. Climbing Stairs"},{"location":"problem/climbing-stairs/#_1","text":"There exists a staircase with N steps, and you can climb up either 1 or 2 steps at a time. Given N , write a function that returns the number of unique ways you can climb the staircase. The order of the steps matters. For example, if N is 4 , then there are 5 unique ways: 1, 1, 1, 1 2, 1, 1 1, 2, 1 1, 1, 2 2, 2 What if, instead of being able to climb 1 or 2 steps at a time, you could climb any number from a set of positive integers X ? For example, if X = {1, 3, 5} , you could climb 1 , 3 , or 5 steps at a time.","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/climbing-stairs/#_2","text":"","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/count-univalue-subtrees/","text":"","title":"008. Count Univalue Subtrees"},{"location":"problem/decode-ways/","text":"","title":"007. Decode Ways"},{"location":"problem/estimate-pi-using-monte-carlo-method/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 The area of a circle is defined as \\({\\pi}r^2\\) . Estimate \\(\\pi\\) to 3 decimal places using a Monte Carlo method. Hint : The basic equation of a circle is \\(x^2 + y^2 = r^2\\) . \u89e3\u7b54 \u00b6 class Solution : def generate_point ( self ) -> tuple : return ( uniform ( - 1 , 1 ), uniform ( - 1 , 1 )) def is_in_circle ( self , coords : tuple ) -> bool : return coords [ 0 ] * coords [ 0 ] + coords [ 1 ] * coords [ 1 ] < 1 def estimate_pi ( self , iterations : int ) -> float : in_circle = 0 for _ in range ( iterations ): if self . is_in_circle ( self . generate_point ()): in_circle += 1 return 4 * in_circle / iterations","title":"014. Estimate \u03c0 using Monte Carlo Method"},{"location":"problem/estimate-pi-using-monte-carlo-method/#_1","text":"The area of a circle is defined as \\({\\pi}r^2\\) . Estimate \\(\\pi\\) to 3 decimal places using a Monte Carlo method. Hint : The basic equation of a circle is \\(x^2 + y^2 = r^2\\) .","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/estimate-pi-using-monte-carlo-method/#_2","text":"class Solution : def generate_point ( self ) -> tuple : return ( uniform ( - 1 , 1 ), uniform ( - 1 , 1 )) def is_in_circle ( self , coords : tuple ) -> bool : return coords [ 0 ] * coords [ 0 ] + coords [ 1 ] * coords [ 1 ] < 1 def estimate_pi ( self , iterations : int ) -> float : in_circle = 0 for _ in range ( iterations ): if self . is_in_circle ( self . generate_point ()): in_circle += 1 return 4 * in_circle / iterations","title":"\u89e3\u7b54"},{"location":"problem/first-missing-positive/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well. For example, the input [3, 4, -1, 1] should give 2 . The input [1, 2, 0] should give 3 . You can modify the input array in-place.","title":"004. First Missing Positive"},{"location":"problem/first-missing-positive/#_1","text":"Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well. For example, the input [3, 4, -1, 1] should give 2 . The input [1, 2, 0] should give 3 . You can modify the input array in-place.","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/function-car-cdr-and-cons/","text":"","title":"005. Function car, cdr and cons"},{"location":"problem/job-scheduler/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 Implement a job scheduler which takes in a function f and an integer n , and calls f after n milliseconds.","title":"010. Job Scheduler"},{"location":"problem/job-scheduler/#_1","text":"Implement a job scheduler which takes in a function f and an integer n , and calls f after n milliseconds.","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/longest-absolute-file-path/","text":"","title":"017. Longest Absolute File Path"},{"location":"problem/longest-collatz-sequence/","text":"","title":"210. Longest Collatz Sequence"},{"location":"problem/longest-consecutive-run-of-1s-in-binary/","text":"Problem \u00b6 Given an integer n , return the length of the longest consecutive run of 1 s in its binary representation. For example, given 156, you should return 3. Solution \u00b6 \u53c3\u8003\u8cc7\u6599 \u00b6 GeeksforGeeks | Length of the Longest Consecutive 1s in Binary Representation","title":"214. Longest Consecutive Run of 1s in Binary"},{"location":"problem/longest-consecutive-run-of-1s-in-binary/#problem","text":"Given an integer n , return the length of the longest consecutive run of 1 s in its binary representation. For example, given 156, you should return 3.","title":"Problem"},{"location":"problem/longest-consecutive-run-of-1s-in-binary/#solution","text":"","title":"Solution"},{"location":"problem/longest-consecutive-run-of-1s-in-binary/#_1","text":"GeeksforGeeks | Length of the Longest Consecutive 1s in Binary Representation","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/longest-substring-with-at-most-k-distinct-characters/","text":"","title":"013. Longest Substring with At Most K Distinct Characters"},{"location":"problem/maximum-sum-of-non-adjacent-elements/","text":"","title":"009. Maximum Sum of Non-Adjacent Elements"},{"location":"problem/merge-intervals/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 Given a list of possibly overlapping intervals, return a new list of intervals where all overlapping intervals have been merged. The input list is not necessarily ordered in any way. For example, given [(1, 3), (5, 8), (4, 10), (20, 25)] , you should return [(1, 3), (4, 10), (20, 25)] . \u53c3\u8003\u8cc7\u6599 \u00b6","title":"077. Merge Intervals"},{"location":"problem/merge-intervals/#_1","text":"Given a list of possibly overlapping intervals, return a new list of intervals where all overlapping intervals have been merged. The input list is not necessarily ordered in any way. For example, given [(1, 3), (5, 8), (4, 10), (20, 25)] , you should return [(1, 3), (4, 10), (20, 25)] .","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/merge-intervals/#_2","text":"","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/order-logger-api-design/","text":"","title":"016. Order Logger API Design"},{"location":"problem/paint-house/","text":"\u984c\u76ee \u00b6 A builder is looking to build a row of N houses that can be of K different colors. He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color. Given an N by K matrix where the \\(n^{\\text{th}}\\) row and \\(k^{\\text{th}}\\) column represents the cost to build the \\(n^{\\text{th}}\\) house with \\(k^{\\text{th}}\\) color, return the minimum cost which achieves this goal.","title":"019. Paint House"},{"location":"problem/paint-house/#_1","text":"A builder is looking to build a row of N houses that can be of K different colors. He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color. Given an N by K matrix where the \\(n^{\\text{th}}\\) row and \\(k^{\\text{th}}\\) column represents the cost to build the \\(n^{\\text{th}}\\) house with \\(k^{\\text{th}}\\) color, return the minimum cost which achieves this goal.","title":"\u984c\u76ee"},{"location":"problem/partition-equal-subset-sum/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 Given a multiset of integers, return whether it can be partitioned into two subsets whose sums are the same. For example, given the multiset {15, 5, 20, 10, 35, 15, 10} , it would return true , since we can split it up into {15, 5, 10, 15, 10} and {20, 35} , which both add up to 55 . Given the multiset {15, 5, 20, 10, 35} , it would return false , since we can't split it up into two subsets that add up to the same sum. \u53c3\u8003\u8cc7\u6599 \u00b6","title":"060. Partition Equal Subset Sum"},{"location":"problem/partition-equal-subset-sum/#_1","text":"Given a multiset of integers, return whether it can be partitioned into two subsets whose sums are the same. For example, given the multiset {15, 5, 20, 10, 35, 15, 10} , it would return true , since we can split it up into {15, 5, 10, 15, 10} and {20, 35} , which both add up to 55 . Given the multiset {15, 5, 20, 10, 35} , it would return false , since we can't split it up into two subsets that add up to the same sum.","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/partition-equal-subset-sum/#_2","text":"","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/product-of-array-except-self/","text":"Problem \u00b6 Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i . For example, if our input was [1, 2, 3, 4, 5] , the expected output would be [120, 60, 40, 30, 24] . If our input was [3, 2, 1] , the expected output would be [2, 3, 6] . Follow-up : what if you can't use division?","title":"002. Product of Array Except Self"},{"location":"problem/product-of-array-except-self/#problem","text":"Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i . For example, if our input was [1, 2, 3, 4, 5] , the expected output would be [120, 60, 40, 30, 24] . If our input was [3, 2, 1] , the expected output would be [2, 3, 6] . Follow-up : what if you can't use division?","title":"Problem"},{"location":"problem/reservoir-sampling/","text":"","title":"015. Reservoir Sampling"},{"location":"problem/search-autocomplete/","text":"","title":"011. Search Autocomplete"},{"location":"problem/serialize-and-deserialize-binary-tree/","text":"Problem \u00b6 Given the root to a binary tree, implement serialize(root) , which serializes the tree into a string, and deserialize(s) , which deserializes the string back into the tree. For example, given the following Node class class Node : def __init__ ( self , val , left = None , right = None ): self . val = val self . left = left self . right = right The following test should pass: node = Node('root', Node('left', Node('left.left')), Node('right')) assert deserialize(serialize(node)).left.left.val == 'left.left'","title":"003. Serialize and Deserialize Binary Tree"},{"location":"problem/serialize-and-deserialize-binary-tree/#problem","text":"Given the root to a binary tree, implement serialize(root) , which serializes the tree into a string, and deserialize(s) , which deserializes the string back into the tree. For example, given the following Node class class Node : def __init__ ( self , val , left = None , right = None ): self . val = val self . left = left self . right = right The following test should pass: node = Node('root', Node('left', Node('left.left')), Node('right')) assert deserialize(serialize(node)).left.left.val == 'left.left'","title":"Problem"},{"location":"problem/sliding-window-maximum/","text":"","title":"018. Sliding Window Maximum"},{"location":"problem/two-sum/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 Given a list of numbers and a number k , return whether any two numbers from the list add up to k . For example, given [10, 15, 3, 7] and k of 17 , return true since 10 + 7 is 17 . Bonus : Can you do this in one pass? \u984c\u89e3 \u00b6 \u66b4\u529b\u641c\u7d22 \u00b6 \u4e00\u500b\u5341\u5206\u76f4\u89c0\u7684\u505a\u6cd5\uff0c\u5c31\u662f\u5728\u4f7f\u7528\u5169\u5c64\u7684 for \u8ff4\u5708\u9010\u500b\u6aa2\u67e5\u9663\u5217 nums \u4e2d\u5169\u5169\u6578\u5b57\u4e4b\u5408\uff0c\u662f\u5426\u6eff\u8db3\u7d66\u5b9a\u7684\u6578\u5b57 target \u3002 def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Nested Iteration (brute force). The brute force way to use nested iteration checking for every pair of numbers. TIME : O(n^2) SPACE : O(1) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" for outer_idx , outer_num in enumerate ( nums ): for inner_idx , inner_num in enumerate ( nums ): if outer_idx != inner_idx and outer_num + inner_num == target : return True return False \u9810\u5148\u6392\u5e8f \u00b6 \u5728\u96e2\u6563\u5e7e\u4f55\u9818\u57df\u4e2d\uff0c\u6709\u4e00\u500b\u88ab\u7a31\u70ba \u6383\u63cf\u7dda\uff08Sweep Line\uff09 \u7684\u6982\u5ff5\u53ef\u4ee5\u7528\u4f86\u89e3\u6c7a\u8a31\u591a\u554f\u984c\uff0c\u5176\u7cbe\u795e\u5c31\u662f\u300c\u5148\u6392\u5e8f\u3001\u518d\u641c\u7d22\u300d\u3002\u8a31\u591a\u984c\u76ee\u90fd\u80fd\u5920\u900f\u904e\u9810\u5148\u6392\u5e8f\u7684\u6982\u5ff5\u4f86\u7c21\u5316\u984c\u76ee\u96e3\u5ea6\uff0c\u751a\u81f3\u5728\u8a31\u591a\u984c\u76ee\u4e2d\uff0c\u5fc5\u9808\u9810\u5148\u6392\u5e8f\u624d\u80fd\u5920\u7372\u5f97\u6700\u4f73\u7684\u6642\u9593\u8907\u96dc\u5ea6\u2026 from bisect import bisect_left from typing import List def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Search After Sorting. Sort the original array to make the element in order. Then we can use searching to check remaing number added to be the target existed or not. TIME : O(nlogn) SPACE : O(1) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" # sort the original list nums . sort () # search the list in order for cur , num in enumerate ( nums ): add_num = target - num idx = binary_search ( nums , add_num ) # Check two more things: # 1. the binary search found the target # 2. the index should't be as same as current number # # We need to check lst[i + 1] and lst[i - 1] to see if there's another # number that's the same value as lst[i]. if not idx : continue elif idx != cur : return True elif idx + 1 < len ( nums ) and nums [ idx + 1 ] == add_num : return True elif idx - 1 >= 0 and nums [ idx - 1 ] == add_num : return True return False def binary_search ( lst , ele ): idx = bisect_left ( lst , ele ) if idx != len ( lst ) and lst [ idx ] == ele : return idx return None \u5728\u6392\u5e8f\u4e4b\u5f8c\uff0c\u6211\u5011\u5728\u5339\u914d target - num \u6642\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u641c\u7d22\u6cd5\uff0c\u9019\u6a23\u4e00\u4f86\u4fbf\u6642\u9593\u8907\u96dc\u5ea6\u53ef\u4ee5\u5f9e\u539f\u5148\u66b4\u529b\u641c\u7d22\u7684 \\(\\mathcal{O}(n^2)\\) \u964d\u81f3 \\(\\mathcal{O}(n\\log{n})\\) \u3002 \u8f14\u52a9\u96c6\u5408 \u00b6 \u5982\u679c\u5beb\u904e LeetCode \u4e0a\u7684\u984c\u76ee\uff0c\u53ef\u80fd\u6703\u767c\u73fe\u9019\u984c\u8207\u4e0a\u9762\u7684\u984c\u76ee\u6709\u4e9b\u5dee\u7570\uff0c\u4e3b\u8981\u5728\u65bc\uff1a LeetCode \u4e0a\u7684\u984c\u76ee\u662f\u8981\u6c42\u51fa\u5169\u6578\u7684\u7d22\u5f15\u4f4d\u7f6e\uff0c\u800c Daily Coding Problem \u5247\u8981\u6c42\u5224\u65b7\u662f\u5426\u5b58\u5728\u6eff\u8db3\u7684\u5169\u6578 LeetCode \u4e0a\u7684\u984c\u76ee\u7d66\u5b9a\u9663\u5217\u5fc5\u5b9a\u80fd\u5920\u627e\u5230\u5169\u6578\uff0c\u800c Daily Coding Problem \u5247\u4e0d\u4e00\u5b9a \u96d6\u7136\u7565\u6709\u4e0d\u540c\uff0c\u4f46\u4f9d\u7136\u53ef\u4ee5\u4f7f\u7528\u8f14\u52a9\u7684\u96dc\u6e4a\u7d50\u69cb\u4f86\u6c42\u89e3\uff0c\u552f\u4e00\u5dee\u5225\u662f\u5728 LeetCode \u4e0a\u70ba\u4e86\u5b58\u653e\u7d22\u5f15\u4f4d\u7f6e\u6240\u4ee5\u5fc5\u9808\u4f7f\u7528\u5b57\u5178\uff0c\u800c\u5728\u6b64\u8655\u6211\u5011\u53ea\u9700\u8981\u4f7f\u7528\u96c6\u5408\u5373\u53ef\uff08\u7576\u7136\uff0c\u7528\u5b57\u5178\u4e5f\u80fd\u6c42\u89e3\uff09\u3002 def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Hashing. Traverse the numbers and remember the nubmers we've seen. And what we should check is if there is another number added to be the target. Take [10, 15, 3, 7] for example: (1) num = 10, seen_num = () , target - num = 7 (2) num = 15, seen_num = (10) , target - num = 2 (3) num = 3 , seen_num = (10, 15) , target - num = 14 (4) num = 7 , seen_num = (10, 15, 3), target - num = 10 (Match!) TIME : O(n) SPACE : O(n) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" seen = set () for num in nums : if target - num in seen : return True seen . add ( num ) return False \u53c3\u8003\u8cc7\u6599 \u00b6 \u6f14\u7b97\u6cd5\u7b46\u8a18 | Sweep Line","title":"001. Two Sum"},{"location":"problem/two-sum/#_1","text":"Given a list of numbers and a number k , return whether any two numbers from the list add up to k . For example, given [10, 15, 3, 7] and k of 17 , return true since 10 + 7 is 17 . Bonus : Can you do this in one pass?","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/two-sum/#_2","text":"","title":"\u984c\u89e3"},{"location":"problem/two-sum/#_3","text":"\u4e00\u500b\u5341\u5206\u76f4\u89c0\u7684\u505a\u6cd5\uff0c\u5c31\u662f\u5728\u4f7f\u7528\u5169\u5c64\u7684 for \u8ff4\u5708\u9010\u500b\u6aa2\u67e5\u9663\u5217 nums \u4e2d\u5169\u5169\u6578\u5b57\u4e4b\u5408\uff0c\u662f\u5426\u6eff\u8db3\u7d66\u5b9a\u7684\u6578\u5b57 target \u3002 def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Nested Iteration (brute force). The brute force way to use nested iteration checking for every pair of numbers. TIME : O(n^2) SPACE : O(1) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" for outer_idx , outer_num in enumerate ( nums ): for inner_idx , inner_num in enumerate ( nums ): if outer_idx != inner_idx and outer_num + inner_num == target : return True return False","title":"\u66b4\u529b\u641c\u7d22"},{"location":"problem/two-sum/#_4","text":"\u5728\u96e2\u6563\u5e7e\u4f55\u9818\u57df\u4e2d\uff0c\u6709\u4e00\u500b\u88ab\u7a31\u70ba \u6383\u63cf\u7dda\uff08Sweep Line\uff09 \u7684\u6982\u5ff5\u53ef\u4ee5\u7528\u4f86\u89e3\u6c7a\u8a31\u591a\u554f\u984c\uff0c\u5176\u7cbe\u795e\u5c31\u662f\u300c\u5148\u6392\u5e8f\u3001\u518d\u641c\u7d22\u300d\u3002\u8a31\u591a\u984c\u76ee\u90fd\u80fd\u5920\u900f\u904e\u9810\u5148\u6392\u5e8f\u7684\u6982\u5ff5\u4f86\u7c21\u5316\u984c\u76ee\u96e3\u5ea6\uff0c\u751a\u81f3\u5728\u8a31\u591a\u984c\u76ee\u4e2d\uff0c\u5fc5\u9808\u9810\u5148\u6392\u5e8f\u624d\u80fd\u5920\u7372\u5f97\u6700\u4f73\u7684\u6642\u9593\u8907\u96dc\u5ea6\u2026 from bisect import bisect_left from typing import List def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Search After Sorting. Sort the original array to make the element in order. Then we can use searching to check remaing number added to be the target existed or not. TIME : O(nlogn) SPACE : O(1) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" # sort the original list nums . sort () # search the list in order for cur , num in enumerate ( nums ): add_num = target - num idx = binary_search ( nums , add_num ) # Check two more things: # 1. the binary search found the target # 2. the index should't be as same as current number # # We need to check lst[i + 1] and lst[i - 1] to see if there's another # number that's the same value as lst[i]. if not idx : continue elif idx != cur : return True elif idx + 1 < len ( nums ) and nums [ idx + 1 ] == add_num : return True elif idx - 1 >= 0 and nums [ idx - 1 ] == add_num : return True return False def binary_search ( lst , ele ): idx = bisect_left ( lst , ele ) if idx != len ( lst ) and lst [ idx ] == ele : return idx return None \u5728\u6392\u5e8f\u4e4b\u5f8c\uff0c\u6211\u5011\u5728\u5339\u914d target - num \u6642\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u641c\u7d22\u6cd5\uff0c\u9019\u6a23\u4e00\u4f86\u4fbf\u6642\u9593\u8907\u96dc\u5ea6\u53ef\u4ee5\u5f9e\u539f\u5148\u66b4\u529b\u641c\u7d22\u7684 \\(\\mathcal{O}(n^2)\\) \u964d\u81f3 \\(\\mathcal{O}(n\\log{n})\\) \u3002","title":"\u9810\u5148\u6392\u5e8f"},{"location":"problem/two-sum/#_5","text":"\u5982\u679c\u5beb\u904e LeetCode \u4e0a\u7684\u984c\u76ee\uff0c\u53ef\u80fd\u6703\u767c\u73fe\u9019\u984c\u8207\u4e0a\u9762\u7684\u984c\u76ee\u6709\u4e9b\u5dee\u7570\uff0c\u4e3b\u8981\u5728\u65bc\uff1a LeetCode \u4e0a\u7684\u984c\u76ee\u662f\u8981\u6c42\u51fa\u5169\u6578\u7684\u7d22\u5f15\u4f4d\u7f6e\uff0c\u800c Daily Coding Problem \u5247\u8981\u6c42\u5224\u65b7\u662f\u5426\u5b58\u5728\u6eff\u8db3\u7684\u5169\u6578 LeetCode \u4e0a\u7684\u984c\u76ee\u7d66\u5b9a\u9663\u5217\u5fc5\u5b9a\u80fd\u5920\u627e\u5230\u5169\u6578\uff0c\u800c Daily Coding Problem \u5247\u4e0d\u4e00\u5b9a \u96d6\u7136\u7565\u6709\u4e0d\u540c\uff0c\u4f46\u4f9d\u7136\u53ef\u4ee5\u4f7f\u7528\u8f14\u52a9\u7684\u96dc\u6e4a\u7d50\u69cb\u4f86\u6c42\u89e3\uff0c\u552f\u4e00\u5dee\u5225\u662f\u5728 LeetCode \u4e0a\u70ba\u4e86\u5b58\u653e\u7d22\u5f15\u4f4d\u7f6e\u6240\u4ee5\u5fc5\u9808\u4f7f\u7528\u5b57\u5178\uff0c\u800c\u5728\u6b64\u8655\u6211\u5011\u53ea\u9700\u8981\u4f7f\u7528\u96c6\u5408\u5373\u53ef\uff08\u7576\u7136\uff0c\u7528\u5b57\u5178\u4e5f\u80fd\u6c42\u89e3\uff09\u3002 def two_sum ( nums : List [ int ], target : int ) -> bool : \"\"\"Hashing. Traverse the numbers and remember the nubmers we've seen. And what we should check is if there is another number added to be the target. Take [10, 15, 3, 7] for example: (1) num = 10, seen_num = () , target - num = 7 (2) num = 15, seen_num = (10) , target - num = 2 (3) num = 3 , seen_num = (10, 15) , target - num = 14 (4) num = 7 , seen_num = (10, 15, 3), target - num = 10 (Match!) TIME : O(n) SPACE : O(n) Args: nums (List[int]): list of numbers target (int): expected sum of any two numbers Returns: bool: whether any two numbers from list `nums` add up to `target`. \"\"\" seen = set () for num in nums : if target - num in seen : return True seen . add ( num ) return False","title":"\u8f14\u52a9\u96c6\u5408"},{"location":"problem/two-sum/#_6","text":"\u6f14\u7b97\u6cd5\u7b46\u8a18 | Sweep Line","title":"\u53c3\u8003\u8cc7\u6599"},{"location":"problem/xor-linked-list/","text":"\u984c\u76ee\u6558\u8ff0 \u00b6 An XOR linked list is a more memory efficient doubly linked list. Instead of each node holding next and prev fields, it holds a field named both , which is an XOR of the next node and the previous node. Implement an XOR linked list; it has an add(element) which adds the element to the end, and a get(index) which returns the node at index. If using a language that has no pointers (such as Python), you can assume you have access to get_pointer and dereference_pointer functions that converts between nodes and memory addresses. \u53c3\u8003\u8cc7\u6599 \u00b6","title":"006. XOR Linked List"},{"location":"problem/xor-linked-list/#_1","text":"An XOR linked list is a more memory efficient doubly linked list. Instead of each node holding next and prev fields, it holds a field named both , which is an XOR of the next node and the previous node. Implement an XOR linked list; it has an add(element) which adds the element to the end, and a get(index) which returns the node at index. If using a language that has no pointers (such as Python), you can assume you have access to get_pointer and dereference_pointer functions that converts between nodes and memory addresses.","title":"\u984c\u76ee\u6558\u8ff0"},{"location":"problem/xor-linked-list/#_2","text":"","title":"\u53c3\u8003\u8cc7\u6599"}]}